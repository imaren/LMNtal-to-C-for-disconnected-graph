# 処理の流れアイデアメモ

## 対象
-非連結グラフ
-hypergraph

atom(Links). atoms1 \ atoms2 :- guard | body.

## memo
- 引数によってアトムリスト分ける
    - a(1),a(!H),a("st"),a(1.0).
        - AL_a_1_i, AL_a_1_h, AL_a_1_s, AL_a_1_f.
    - a(1,!H,!B,2).
        - AL_a_4_ihhi


## 処理
- ピリオドで区切る．
- ルールと初期状態を分ける．
<!-- - ルールについて解析 -->
- ルールに番号付ける
    - (別に管理できればなんでもいい)
- ルールに使用されうるアトムの種類をリストアップ
    - ->必要なアトムリストが決定
    - 例 : a, b :- c. --> a_0 と b_0
- それぞれのルールのボディでルールが発火しうるアトムが生成される個数を数える
    - 例1 : {a, b :- .} --> 0個
    - 例2 : {a, b :- b. b :- c.} --> 1個
    - 例3 : {a :- b. c :- b.} --> 0個
- それぞれのアトムの出現をリストアップ
    - 例：a :- b. a, a :- c. なら、 a_0 の出現は rule1 に 1つ と rule2 に 2つ
- それぞれのアトムの出現についてペアを決定．この時アトムが生成される個数の情報も持っていく
    - pair[0] は 消えるアトムのリスト, pair[1] は消えないアトムのリスト
    - target が消えるかどうかも持っておく
    - 例：a :- b. a \ b :- c. なら、以下の3つ
        - target = a_0, del = true,  pair[0] = none, pair[1] = none, atom_inc = 1
        - target = a_0, del = false, pair[0] = b_0,  pair[1] = none, atom_inc = 0
        - target = b_0, del = true,  pair[0] = none, pair[1] = a_0,  atom_inc = 0
- ターゲットごとに分けておく
    - target = a_0 の情報のリストと target = b_0 の情報のリストは別々に扱われる
- ルール実行順を決定
    - 優先基準
        - ターゲットのアトムが消える
        - ルールが発火しうるアトムの増加数が少ない
        - ペアが少ない
- それぞれのアトムにの出現についてガードを分析して、対応するプログラムと必要なデータ構造をリストアップ
    - ガードがない
        - pair を探して消すだけの処理を生成
    - ガードに加減算や new 命令がない（アトムの引数に上下限がある）
        - 下限から上限までを index とする配列を作る（HL なら種類数，float なら切り捨て）
            - int min, int max, int offset = -min, int rule_i_occurre[max-min]
            - 最適化できる場合は2次元とかにする．
    - ガードに加減算や new 命令がある
        - hash table 作る, 
            - 配列と違って、デフォルトで tuple をキーにする
    - uniq が含まれる
        - history table を作る（上下限の解析結果を使う）
- main に各データ構造の宣言・初期化と関数呼び出し（と finalize）を並べる

- 初期状態について解析
    - hyperlink に一意の ID をつける
    - ルール左辺に出現するアトムだけ抽出
